WHY DO WE NEED A LANGUAGE ?
    Before starting an application , it resides in SSD (solid state drive) of the machine.
    When we start an application the compiler converts the code of the application into 0s and 1s
    This code is fed to RAM which understands this code and runs the application.

    Directly writing code in 0s and 1s is quite difficult hence languages like js,python,c++ are used.

INTERPRETED VS COMPILED LANGUAGES :
    Languages which take the code file and form a compiled file of it before running it are compiled
    languages e.g c,c++ These languages do not run any code if there is an error in the code and hence 
    are safer to use.

    Langueges which compile code line by line are interpreted languages e.g python, js etc.
    If there is an error in the code . The code above the error line will still work.

STATIC VS DYNAMIC LANGUAGEES :
    Static languages set the type of a variable at the time of decleration and this type cannot 
    be changed afterwards e.g c++ hence These languages are efficient as they are less prone to 
    errors.

    Dynamic languages can changes type of a variable anytime e.g python , js . These languages are
    prone to errors and hence typescript was developed to overcome such and many more limitations of js.

NOTE : 
    Javascript is a single threaded language i.e it uses one core at a time.

//  Syntax Parsers : A program that reads the code and determines 
//                     what it does if its grammer is correct.

//  Lexical Environment : The environment or place where the code is literally 
//                          written in the file or project.    

// Execution Context : A wrapper to help manage the code that is running.
//                          decides which lexical environment is currently
//                          running.

// Event Queue : Events which are called by external engines like browser window
//                are saved in a queue called event queue.For an event to occur the 
//                the exucution context from previous events or code must be empty.

// Dynamic Typing : Js engine figures out what type of data a variable holds by 
//                  itself during execution

// Operators : Functions which are written differently(infix notation instead of prefix) than other normal functions
//                which generally take two values and return one value

// Operator Presedence : which gets called first.
// Operator Associativity : order in which operators are called in when they have same precedence.
//                          Example :
                            {
                                let a = 2 ,b = 3 ,c=4
                                a = b = c
                                console.log(a,b,c) 
                                
                                // returns 4,4,4
                                // because = has right to left(js documentation) associativity b=c is executed first
                                // which sets b = 4 and then a = b is executed which sets a = 4.
                            }

// Coercion : convert value from one type to another.
                            {
                                let a = 1
                                let b = '2'
                                console.log(a+b) // return '12' as both are treated as string
                                console.log(typeof(a+b)) // string
                                console.log(a-b) //converts both to number hence -1
                                console.log(typeof(a-b)) // number
                                1 -> true
                                0 -> false
                                "" -> false
                                "string" -> true

                            }
                
// Note: 
    // There are total 6 falsy values : false,0,'',null,NaN,undefined . any other values are truthy values including [],{}.
    // 'undefined is converted to NaN'
    // 'null is converted to 0'

// Comparison operators :      
        {
            console.log(1<2<3) // return true 
            console.log(6<4<3) // returns true 
            // but why? it should be false mathematically?

            // < operator has left to right associativity
            // and hence 6<4 is first executed which returns
            // false now expression becones false < 3 here now 
            // coercion happens and false is converted to 0
            // so expression is 0<3 which return true
        }
        //NOTE - '==' and '!=' uses type coercion while '===' and '!==' are strict and donot
        //          coerce values


